# 🏗️ **Type Structure Architecture Guide**

## 📋 **Overview**

The Keystroke App implements an **excellent type structure** that follows industry best practices for maintainability, type safety, and architectural purity. This document describes our unified type system that leverages Prisma's automatic type generation while maintaining clean separation between client and server concerns.

---

## 🎯 **Core Architectural Principles**

### 1. **Single Source of Truth**

- **Database Schema**: `prisma/schema.prisma` is the single source of truth for all data structures
- **Type Generation**: `prisma-generator-typescript-interfaces` automatically creates client-safe types
- **Zero Duplication**: No manual type definitions that duplicate database schema

### 2. **Prisma-Free Client Architecture**

- **Client-Side**: Never imports `@prisma/client` types directly
- **Server-Side**: Uses Prisma types only in server actions and API routes
- **Type Conversion**: Automatic conversion between Prisma and internal types at boundaries

### 3. **Unified Enum System**

- **Generated Enums**: All enums auto-generated from Prisma schema
- **Display Names**: Centralized display name mappings for UI consistency
- **Type Safety**: Full TypeScript support with IntelliSense

---

## 🗂️ **Type System Structure**

```
src/core/types/
├── index.ts              # 🎯 Main entry point (auto-generated from Prisma)
├── display-names.ts      # 🏷️ Centralized display name mappings
├── database.ts           # 🗄️ Database-specific type utilities
├── dictionary.ts         # 📚 Dictionary domain types
├── user.ts              # 👤 User domain types
├── practice.ts          # 🎮 Practice domain types
└── api.ts               # 🔌 API request/response types
```

---

## 🔧 **Type Generation Process**

### **Prisma Configuration**

```prisma
generator typescriptInterfaces {
  provider          = "prisma-generator-typescript-interfaces"
  output            = "../src/core/types/index.ts"
  prettier          = true
  optionalRelations = true
  omitRelations     = false
  enumType          = "object"
  headerComment     = "Generated by prisma-generator-typescript-interfaces - Zero-dependency types for client-side use\\nDo not edit manually - run 'prisma generate' to update"
}
```

### **Generated Output**

- **Types**: All model interfaces with proper TypeScript typing
- **Enums**: Const assertions for runtime and compile-time safety
- **Relations**: Optional relations for flexible usage
- **Zero Dependencies**: No Prisma client dependencies in generated types

### **Regeneration Command**

```bash
pnpm p-generate  # Regenerates types from schema
```

---

## 📚 **Enum System & Display Names**

### **Enum Definition Example**

```typescript
// Auto-generated from Prisma schema
export type PartOfSpeech = 'noun' | 'verb' | 'adjective' | 'adverb';
// ... more values

export const PartOfSpeech = {
  noun: 'noun',
  verb: 'verb',
  adjective: 'adjective',
  adverb: 'adverb',
  // ... more values
} satisfies Record<string, PartOfSpeech>;
```

### **Centralized Display Names**

```typescript
// src/core/types/display-names.ts
export const PART_OF_SPEECH_DISPLAY_NAMES: Record<PartOfSpeech, string> = {
  noun: 'Noun',
  verb: 'Verb',
  adjective: 'Adjective',
  adverb: 'Adverb',
  // ... all enum values mapped to human-readable names
};

// Consolidated access
export const DISPLAY_NAMES = {
  partOfSpeech: PART_OF_SPEECH_DISPLAY_NAMES,
  language: LANGUAGE_DISPLAY_NAMES,
  difficulty: DIFFICULTY_DISPLAY_NAMES,
  // ... all display name mappings
} as const;
```

### **Usage in Components**

```typescript
import { DISPLAY_NAMES, PartOfSpeech } from '@/core/types';

// Type-safe display name access
const displayName = DISPLAY_NAMES.partOfSpeech[PartOfSpeech.noun]; // "Noun"

// Helper function usage
import { getPartOfSpeechDisplayName } from '@/core/types/display-names';
const displayName = getPartOfSpeechDisplayName('noun'); // "Noun"
```

---

## 🔄 **Client-Server Type Boundaries**

### **Server Actions & API Routes**

```typescript
// ✅ Server-side: Can use Prisma types
import { PrismaClient, User } from '@prisma/client';
import type { UserWithRelations } from '@/core/types';

export async function updateUser(
  data: Partial<User>,
): Promise<UserWithRelations> {
  const prisma = new PrismaClient();
  // Use Prisma types directly
  const user = await prisma.user.update({ where: { id }, data });
  // Convert to internal type before returning
  return convertPrismaUserToInternal(user);
}
```

### **Client Components**

```typescript
// ✅ Client-side: Use internal types only
import type { User, LanguageCode } from '@/core/types';

interface UserProfileProps {
  user: User;  // Internal type, not Prisma type
  onLanguageChange: (lang: LanguageCode) => void;
}

export function UserProfile({ user, onLanguageChange }: UserProfileProps) {
  // Safe to use in browser environment
  return <div>{user.name}</div>;
}
```

---

## 🎯 **Type Safety Best Practices**

### **1. Import Patterns**

```typescript
// ✅ Correct: Import from core types
import { User, PartOfSpeech, LanguageCode } from '@/core/types';
import { DISPLAY_NAMES } from '@/core/types/display-names';

// ❌ Wrong: Never import Prisma types in client code
import { User } from '@prisma/client';
```

### **2. Optional Properties with exactOptionalPropertyTypes**

```typescript
// ✅ Correct: Explicit undefined for optional properties
interface FormValues {
  name: string;
  email?: string | undefined; // Explicit undefined
  phone?: string | undefined;
}

// ❌ Wrong: Implicit undefined (fails with exactOptionalPropertyTypes)
interface FormValues {
  name: string;
  email?: string; // Implicit undefined
}
```

### **3. Enum Usage**

```typescript
// ✅ Correct: Use enum values directly
const userLanguage: LanguageCode = 'en';
if (userLanguage === LanguageCode.en) {
  /* ... */
}

// ✅ Correct: Type-safe enum iteration
Object.values(LanguageCode).forEach((lang) => {
  console.log(DISPLAY_NAMES.language[lang]);
});
```

---

## 🏗️ **Domain-Specific Types**

### **Dictionary Domain**

```typescript
// src/core/types/dictionary.ts
export interface WordWithDefinitions extends Word {
  definitions: Definition[];
  audioFiles?: Audio[];
}

export interface SearchFilters {
  query?: string;
  partOfSpeech?: PartOfSpeech[];
  difficulty?: DifficultyLevel[];
  learningStatus?: LearningStatus[];
}
```

### **User Domain**

```typescript
// src/core/types/user.ts
export interface UserPreferences {
  baseLanguageCode: LanguageCode;
  targetLanguageCode: LanguageCode;
  dailyGoal: number;
  notificationsEnabled: boolean;
}

export interface UserWithSettings extends User {
  userSettings: UserSettings;
  preferences: UserPreferences;
}
```

---

## 📊 **Settings Architecture**

### **Redux + Database Pattern**

```typescript
// All settings follow this pattern:
// 1. Redux store for client state
// 2. Database persistence via server actions
// 3. Automatic synchronization

// src/core/state/features/settingsSlice.ts
export interface TypingPracticeSettings {
  wordsCount: number;
  autoSubmitAfterCorrect: boolean;
  showDefinitionImages: boolean;
  playAudioOnStart: boolean;
  showProgressBar: boolean;
}

// Usage in components
import { useTypingPracticeSettings } from '@/core/shared/hooks/useSettings';

export function TypingPracticeComponent() {
  const { settings, updateSetting } = useTypingPracticeSettings();
  // Settings are automatically persisted to database
}
```

---

## 🔍 **Type Validation & Schema**

### **Zod Integration**

```typescript
// Form schemas align with internal types
import * as z from 'zod';
import type { WordFormValues } from '@/core/types';

const wordFormSchema = z.object({
  word: z.string().min(1, 'Word is required'),
  phonetic: z.string().optional(),
  etymology: z.string().optional(),
  // ... matches WordFormValues interface exactly
});

// Type-safe form handling
const form = useForm<WordFormValues>({
  resolver: zodResolver(wordFormSchema),
});
```

---

## 🚀 **Performance Optimizations**

### **Tree Shaking**

- **Modular Exports**: Each domain has separate type files
- **Selective Imports**: Import only needed types
- **Bundle Optimization**: Unused types are automatically eliminated

### **Type-Only Imports**

```typescript
// ✅ Correct: Type-only imports for better tree shaking
import type { User, LanguageCode } from '@/core/types';

// ✅ Correct: Mixed imports when needed
import { LanguageCode, type User } from '@/core/types';
```

---

## 🧪 **Testing & Type Safety**

### **Type Testing**

```typescript
// Type-safe test utilities
import type { User, LanguageCode } from '@/core/types';

export function createMockUser(overrides?: Partial<User>): User {
  return {
    id: 'test-id',
    name: 'Test User',
    email: 'test@example.com',
    baseLanguageCode: LanguageCode.en,
    // ... all required fields with type safety
    ...overrides,
  };
}
```

---

## 📈 **Migration & Evolution**

### **Schema Changes**

1. **Update Prisma Schema**: Modify `prisma/schema.prisma`
2. **Generate Migration**: `pnpm p-migrate`
3. **Regenerate Types**: `pnpm p-generate`
4. **Update Components**: TypeScript will show what needs updating

### **Breaking Changes**

- **Enum Updates**: Automatically reflected in all components
- **Field Changes**: Compile-time errors guide necessary updates
- **Relationship Changes**: Type system ensures consistency

---

## 🏆 **Benefits Achieved**

### **Developer Experience**

- **IntelliSense**: Full autocomplete for all types and enums
- **Compile-Time Safety**: Catch errors before runtime
- **Refactoring**: Safe automated refactoring across codebase

### **Maintainability**

- **Single Source of Truth**: Database schema drives all types
- **Zero Duplication**: No manual type maintenance
- **Consistency**: Automatic consistency across client and server

### **Performance**

- **Bundle Size**: Only used types included in bundles
- **Runtime Safety**: No Prisma client in browser bundles
- **Type Stripping**: TypeScript types removed in production

---

## 📋 **Usage Checklist**

### **For New Components**

- [ ] Import types from `@/core/types`
- [ ] Use display names from `@/core/types/display-names`
- [ ] Never import `@prisma/client` in client code
- [ ] Use type-only imports when possible

### **For New Features**

- [ ] Define domain-specific types in appropriate files
- [ ] Add display names for new enums
- [ ] Update Prisma schema if database changes needed
- [ ] Follow Redux + database pattern for settings

### **For Schema Changes**

- [ ] Update `prisma/schema.prisma`
- [ ] Run `pnpm p-migrate`
- [ ] Run `pnpm p-generate`
- [ ] Update display names if new enums added
- [ ] Fix TypeScript errors in affected components

---

## 🔗 **Related Documentation**

- [Prisma Schema](../prisma/schema.prisma)
- [Component Architecture](./COMPONENT_REFACTORING_SUMMARY.md)
- [Settings Architecture](./SETTINGS_ARCHITECTURE.md)
- [Database Schema](./DATABASE_DESCRIPTION.md)

---

**🎉 This type structure represents industry best practices for TypeScript applications with database integration, providing maximum type safety, maintainability, and developer experience.**
